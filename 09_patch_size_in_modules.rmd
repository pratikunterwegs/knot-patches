---
editor_options:
  chunk_output_type: console
---

# Patch metrics in relation to module size

## Prepare libraries

```{r prep_libs_03, eval=FALSE}
library(tidyverse)

# for plots
library(ggplot2)
library(plotly)
library(htmlwidgets)


# ci function
ci <- function(x){qnorm(0.975)*sd(x, na.rm = TRUE)/sqrt(length(x))}
```

## Read in module data

```{r read_modules, eval=FALSE}
# read in data
modules <- read_csv("data/data_2018_patch_modules_small_scale.csv")
data <- read_csv("data/data_2018_good_patches.csv")
```

Choose the smallest temporal scale.

```{r choose_scale, eval=FALSE}
modules <- filter(modules, time_scale == 1)
```

## Add patch data

```{r add_patch_data, eval=FALSE}
# get mean and ci for patches
mod_data <- modules %>% 
  inner_join(data)

# count unique ids in each mod-time-chunk and filter on 2
mod_data <- mod_data %>% 
  group_by(spatial_scale, module, time_chunk) %>% 
  mutate(xc = mean(x_mean, na.rm = T),
         yc = mean(y_mean, na.rm = T),
         wlc = mean(waterlevel_start),
         wlc = plyr::round_any(wlc, 50),
         n_uid = length(unique(id)),
         n_patches = length(unique(x_mean)))
```

Filter for minimum 2 indiviudals per module, and minimum of 3 patches.

```{r filter_n_id, eval=FALSE}
mod_data <- filter(mod_data, n_uid > 1, n_patches > 3, !is.na(duration),
                   spatial_scale <= 100)
```

## Patch size ~ number of patches in a module

```{r patch_size_module, eval=FALSE}
# count patches in module, and get mean patch area, duration, circ
# summarise data
mod_data_summary <- mod_data %>% 
  mutate(n_patches = plyr::round_any(n_patches, 1)) %>% 
  group_by(spatial_scale, wlc, n_patches) %>% 
  # summarise_at(vars(area, duration, circularity, distBwPatch),
  #              list(~mean(., na.rm = T))) %>% 
  pivot_longer(cols = c("area", "duration", 
                        "circularity", "distBwPatch",
                        "distInPatch", "dispInPatch")) %>% 
  drop_na() %>% 
  group_by(spatial_scale, wlc, n_patches, name) %>% 
  summarise_at(vars(value),
               list(~mean(., na.rm = T),
                    ~ci(.)))

# remove data above the 95% percentile
quantile(mod_data_summary$n_patches, probs = c(0.05, 0.90))

# get by n patch
mod_data_summary <- mod_data_summary %>% 
  filter(n_patches <= 20)
```

## Get patches not in modules

```{r eval=FALSE}
# split modules by spatial scale
tmp_modules <- filter(modules, spatial_scale <= 100)
tmp_modules <- split(tmp_modules, tmp_modules$spatial_scale)

indep_patches <- map(tmp_modules, function(df){
  tmp_df <- anti_join(data, df)
  tmp_df <- mutate(tmp_df,
                   spatial_scale = unique(df$spatial_scale),
                   n_patches = 1,
                   wlc = plyr::round_any(waterlevel_start, 50))
  
  # summarise metrics
  tmp_df <- pivot_longer(tmp_df,
                           cols = c("area", "duration", 
                        "circularity", "distBwPatch",
                        "distInPatch", "dispInPatch")) %>% 
  drop_na() %>% 
  group_by(spatial_scale, wlc, n_patches, name) %>% 
  summarise_at(vars(value),
               list(~mean(., na.rm = T),
                    ~ci(.)))
  return(tmp_df)
})

indep_patches <- bind_rows(indep_patches)
```


```{r eval=FALSE}
# add indep patches
mod_data_summary <- bind_rows(mod_data_summary, indep_patches)
# make list
mod_data_summary <- split(mod_data_summary, mod_data_summary$name)
```

```{r plot_metrics_size, eval=FALSE}
# do plot over list

list_plot <- map2(mod_data_summary, 
                  letters[1:6],
                  function(df, name){
  ggplot(df, aes(n_patches, mean))+
    geom_point(aes(fill = factor(spatial_scale)),
               size = ifelse(df$n_patches > 1, 1, 2),
               shape = ifelse(df$n_patches > 1, 2, 21),
               show.legend = F)+
    geom_errorbar(aes(ymin = mean - ci, ymax = mean+ci,
                      col = factor(spatial_scale)), 
                  width = 1, size = 0.2,
                  show.legend = F)+
    geom_smooth(method = "glm", se = F,
                col = "black", size = 0.2)+
    scale_colour_brewer(palette = "Set1")+
    scale_x_continuous(breaks = c(1, seq(3,20,3)))+                  
    theme_test(base_size = 8)+
    theme(legend.position = "none")+
    facet_grid(spatial_scale~wlc,
               labeller = label_both,
               # scales = "free_y",
               as.table = FALSE,
               switch = "both")+
    labs(x = "# patches",
         y = glue::glue('{unique(df$name)}'),
         title = glue::glue('({name})'))  
})

fig_metrics_social <- patchwork::wrap_plots(list_plot, ncol = 2)

ggsave(fig_metrics_social, filename = "figs/fig_metrics_social.png",
       dpi = 300, height = 12, width = 12)
```

```{r}
knitr::include_graphics("figs/fig_metrics_social.png")
```

